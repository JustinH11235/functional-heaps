# functional-heaps

The goal of this repo is to implement a purely functional binary heap in OCaml.

## What's required to be purely functional?
For a data structure to be purely functional, there can be no mutable parts of the data structure.

The major problem this causes is that typically, a binary heap is best implemented using an array (which is mutable). Using an array would likely give us better cache locality and speed up certain operations.

Instead I chose to implement the binary heap as a complete binary tree with left and right pointers (I also store a min_height and max_height).

Here are some of the operations that become more difficult to perform efficiently:
* `pop O(logn)` - typically, this is done by moving the last element to the root, then swapping from the root down to the element's correct position. With an array this is simple, we know the index of the last element because the length operation is O(1), and since an array is mutable, we can in O(1) remove it from the last element and replace the root with it. My solution is to store a min_height (defined as `min(left's height, right's height) + 1`), and a max_height (defined as `max(left's height, right's height) + 1`). Using the max_height, I can determine whether to recurse left or right to find the last element in O(logn): I should only go left if the max_height of left > max_height of right, because that means the left's last level has some elements, and the right's last level has none. In the only other case of heights being equal, I should go right, since there is at least one element on both sides, so the last one will be to the right.
* `push O(logn)` - this is difficult because we need to know how to recurse downwards in O(logn) to find the next open space in our tree. I use min_height to determine this: I should only go right if the min_height of left > min_height of right, because that means the left's last level is completely filled, whereas the right's is not completely filled. In the only other case of heights being equal, I should go left, since there is still open space in the left side.
* `of_list O(n)` (a.k.a. heapify/build heap) - Building a heap from a list in O(n) is difficult, mainly because we don't have O(1) random access to elements of the given list. My approach consists of two parts. The first part is to create an unordered complete binary tree, and the second is to heapify that tree. The first part is the challenging one to implement without becoming worse than O(n), our recursive function that creates our tree needs to know how many of the list elements to use for its left and right sub-trees, which is dependent on how much of the last level is filled. My implementation calculates how many elements to give its left and right sub-trees using some math to determine how many elements are on the last level, then passes that information to recursive calls so the children know how much of the list to consume. The second part can be done by heapifying from the bottom up, and since we have shared state, we can stop heapifying early once each root element has been swapped to the correct location in the ordered sub-tree.
